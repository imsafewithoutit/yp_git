# КРАТКИЙ (ИЛИ НЕ ОЧЕНЬ) КОНСПЕКТ ПО GIT


### Системы контроля версий

Системы контроля версий (version control system, а в некоторых вариантах встречается source control management (системы управления исходным кодом):
1. локальные - хранятся на 1 ПК для 1 юзера; 
2. централизованные - на 1 сервере для неск.юзеров; 
3. децентрализованные - на 1 или неск.серверах + на каждом ПК у каждого юзера.

Если есть изменение в файле, Git делает снимок (snapshot)  и сохраняет его в локальную БД: т.е. для любого действия с файлом генерируется свой SHA-1 (хэш-сумма), и именно к нему, а не к самому файлу, и обращается Git для отслеживания изменений.

У каждого файла в проекте 2 состояния: **tracked** и **untracked** (меняется после добавления в индекс).

В Git 3 директории: **working directory** (папка с файлами проекта), **staged area** (=staging index), **repository** (папка .git).

У отслеживаемого файла в Git есть 3 состояния: **modified** (изменено, но не зафиксировано) -> **staged** (изменено и будет зафиксировано в след.коммит), и -> **commited** (зафиксировано в ЛР).

-> т.е. Git хранит снимок текущей версии WD + сохраняет в индекс подготовленные к фиксации изменения + фиксирует их с помощью **КОММИТА** - процесса создания ревизии, т.е. слепка изменений (это не snapshot!).

---

Процесс переключения между ревизиями - checkout.

Процесс создания ревизии, т.е. фиксация состояния кода - commit.

Набор файлов и директорий, которые находятся под контролем версий - репозиторий.

В любых СКВ рабочий процесс универсальный:
1. Инициализация (создание) репозитория
2. Добавление новых файлов
3. Коммит
4. Операции с файлами (добавление, удаление, изменение)
5. Коммит

---

Каждый новый коммит базируется на коде предыдущего коммита. С точки зрения информатики, коммиты выстраиваются в так называемый *односвязный список*. В таком списке каждый элемент ссылается на предыдущий. Последний элемент при этом называется головой списка (*HEAD*). И так же как в односвязном списке, новый коммит (как элемент списка) имеет ссылку на старый (предыдущий), а предыдущий — на свой предыдущий, и так далее до первого коммита, который никуда не ссылается, т.к. он первый. 

Сам список коммитов тоже имеет название — *ветка* (branch). 

Но: Git это не просто односвязный список — это множество односвязных списков, переплетенных вместе.

---


### Команды Git config, help

3 уровня настроек git: 
1. на уровне системы, выводятся и сохраняются с опцией --system, сами настройки хранятся в program files > git > etc > gitconfig. 
2. на уровне пользователя, с опцией --global, хранятся в c:/users/пользователь/gitconfig. 
3. на уровне проекта, без --опции, хранятся в .git/config. 

Если не задана настройка для проекта, будет применяться --global, а если и ее нет - то --system.

```bash
git config --list 
- показать список всех настроек (также можно указать уровень), либо можно просто открыть файл с настройками: "cat ~/.gitconfig"

git config настройка 
- показать значение этой настройки

git config --уровень --add настройка значение
- добавить новую настройку (см. примеры ниже)

git config --global user.name "имя"
git config --global user.email "почта"
- имя и почту пользователя

git config --global core.editor редактор 
- выбрать текстовый редактор (по умолчанию - vim)

git config --global --add color.ui true
- раскрашивать пользовательский интерфейс

git config --global core.quotepath off
- отображать unicode, чтобы читались кириллич.символы в названиях файлов, сообщениях коммитов и т.п.

git config --global branch.autosetuprebase always
- выполнять все команды git pull с опцией --rebase (ее не нужно будет указывать, достаточно только "git pull")

git config --global alias.псевдоним команда
- добавить алиас к команде. 

git config --global alias.псевдоним '!команда'
- если команда с опциями, т.е. есть пробелы - тогда нужно обернуть в кавычки. Если команда внешняя, а не команда git - тогда перед ней ставим "!"

which git 
- показать директорию, где размещен git (сама система, не ЛР)

git --version 
- показать версию git (обновить git можно из cmd, командой "git update-git-for-windows")

git help команда
- показать справку для команды (в браузере)

git help 
- вывести общее меню справки (в консоли)

gitk
- открыть gui-клиент для текущего проекта
```

### Инициализация Git, команды add, commit

```bash
git init
- инициализировать новый ЛР (в текущей директории!)

git init имядиректории
- в текущей директории создать директорию с таким именем и уже в ней инициализировать ЛР

git init --bare 
- создать "голый" ЛР (не имеет рабочего каталога, а содержит только каталог .git - нужен, например, для хранения только самих ревизий (т.е. изменений), а не всей копии проекта).


rm -rf .git
- "разгитить" папку, т.е. удалить, например, случайно созданный репозиторий (т.е. удаляет папку .git)


git add файл
git add *.расширение (все файлы с таким расширением из текущей папки)
git add директория/ 
git add директория/\*.расширение (все файлы с таким расширением из указанной папки)
git add . либо git add --all

или

git add -i
- запустить интерактивный режим с опциями выбора изменений для коммита. Например, можно разбить изменения в 1 файле на неск.частей и добавить в индекс одну или несколько из них. Для этого: нажать "p" (patch) -> выбрать файл/ы -> нажать "s" (split) -> выбрать часть (ответить y/n). 

Список команд в интерактивном режиме вызывается через "?".

Опции для команды add:
-f (или --force): добавить и файлы которые игнорируются .gitignore
-n (или --dry-run): просто показать файлы, которые будут добавлены (например, при выборе всех через ".") 
-p (или --patch) добавлять файлы по одному с выводои изменений и с подтверждением по каждому файлу.


git commit -m 'комментарий' 

Для крупных изменений комментарий можно делать в формате "заголовок - пустая строка - описание", через реактор (см. ниже). Но: при выводе git log с опцией --oneline или git shortlog будут показаны только "заголовки".

Если просто git commit - откроется редактор ( > i > комментарий > esc > :wq (сохранить) или :q! (не сохранять) > enter)

git commit имяфайла 
- закоммитить только этот файл, остальные проигнорить и оставить в индексе.

git commit -a (или --all)
- добавить ВСЕ изменения в индекс (кроме неотслеживаемых или удаленных файлов) и сразу закоммититить. Полное написание команды: git commit -am 'комментарий'.

--amend 
- изменить последний коммит (если нужно изменить комментарий или внести/удалить в коммит еще файл). Фактически выполняется reset + коммит с новыми данными (и новым хэшем!), только сам новый коммит не создастся, но новые проиндексированные изменения перезапишутся в последний коммит с новым комментарием, либо просто перезапишется комментарий, если изменений не было.

--amend --no-edit 
- если нужно перезаписать данные в коммит, но не менять комментарий.

! amend не надо применять если уже запушили, т.к. могут быть конфликты (как и при revert).
```

### Команды Git status, diff, log

```bash
git status
- показать изменения в рабочей директории по сравнению с последним коммитом, т.е.: появились ли новые (неотслеживаемые) / изменились или удалились ли старые (отслеживаемые) файлы?

git status -s 
- вывод изменений в одну строку


git diff
- показать все изменения во всех проиндексированных файлах (т.е сравнить индекс с WD)

git diff HEAD
- сравнить WD и последний коммит

git diff HEAD^ HEAD
- сравнить последний и предпоследний коммит

git diff --cached (или --staged)
- сравнить индекс и последний коммит

git diff ветка
- сравнить WD с определенной веткой

git diff ветка1 ветка2
- сравнить ветки

git diff ветка1...ветка2
- показать все изменения в ветке2 с момента создания ветки1

git diff коммит1..коммит2
- показать все изменения от коммита1 до коммита2

git diff имяфайла
- показать изменения в конкретном файле

git diff файл1 файл2
- показать различия между файлами

git diff --diff-filter= (значения:A,C,D,M,R)
- показать определенные изменения: added, copied, deleted, modified, renamed

git diff --color-words
- показать изменения с выводом в одну строку и цветовым разделением

git diff -w
- игнорировать различия в пробелах при сравнении строк

git diff --stat  
- показать изменения в каждом файле за определенное время. Можно добавить параметры: --stat-width= (ширина вывода), --stat-name-width= (ширина имени файла), --stat-count= (количество строк вывода).


git log
- показать историю коммитов. Опции:

git log -p
- подробно (в пейджере, выход из него - через q) покажет только те коммиты, где были изменения в самих файлах, а не где файлы добавили/удаляли.

git log -- файл_или_директория
- покажет только коммиты, в которых были изменения в файле/директории

git log ветка2..
- покажет только те коммиты в текущей ветке, которых еще нет в ветке1

git log ..ветка2 
- покажет только те коммиты в ветке2, которых ещё нет в текущей

git log --no-merges
- не покажет коммиты слияний и коммиты решений конфликтов

git log --abbrev-commit	
- покажет у коммитов только первые символы хэша

git log --oneline
- покажет каждый коммит в одну строку: только сокращенный хэш и комментарий

git log -n число
- покажет определенное число коммитов

git log --max-count=число
- покажет число коммитов не больше заданного

git log --graph
- покажет историю в виде ascii-графика, со связями между коммитами.

git log --pretty=oneline (=short =full =fuller)
- покажет историю с определенным уровнем вывода деталей

git log --pretty=format:"%h - %an, %ar : %s"
- покажет историю в установленном формате (в примере: "хэш - автор, дата : комментарий")

git log --since=2020-05-30 (--until=2020-05-30) (--since='5 minutes ago')
- покажет коммиты до/после определенной даты или интервала времени

git log --author="имяавтора"
- покажет только коммиты, сделанные указанным пользователем

git log --grep="текст"
- покажет коммиты с найденным в комментариях текстом (через обычную команду grep) 

git log --stat
- покажет статистику по каждому коммиту (сколько файлов изменено и т.п.)

git log --shortstat
- то же, что и --stat, но с общей статистикой (общие цифры на весь коммит, а не по каждому файлу)

git log --skip=число
- пропустит сколько-то последних коммитов

git log --name-only	
- покажет список изменённых файлов

git log --name-status	
- покажет список изменённых файлов + информацию о добавлении/изменении/удалении

git log --relative-date	
- покажет дату коммита в относительном формате (например, "2 weeks ago").
```


### Работа с удаленным репозиторием

master - имя по умолчанию для исходной ветки (которая создалась при git init)

origin - имя по умолчания для УР (присваивается при git clone, потом можно переименовать: git clone -o новоеимя)

---

```bash
git remote
- показать все доступные УР

git remote -v 
- показать УР с их url и именем пользователя

git remote add короткоеимя полныйurl
- добавить УР и присвоить ему короткое имя

git remote show УР
- показать подробную инфу по указанному УР

git remote rename староеимя новоеимя
- переименовать УР

git remote rm УР
- удалить запись о УР из ЛР (т.е. отключиться от него - файлы в ЛР и сам УР на сервисе останутся)

git remote set-url адрес
- изменить протокол с ssh на https
```

---

ПРОЦЕСС СОЗДАНИЯ И ПРИВЯЗКИ SSH-КЛЮЧА В GITHUB:

1. Проверка наличия SSH-ключа:

```bash
cd ~
- перейти в домашнюю директорию 

ls -la .ssh/
- вывести список созданных ключей (если список пустой или директория не найдена - значит, ключ еще не создан)
```

2. Генерация SSH-ключа:

```bash
ssh-keygen -t ed25519 -C "электронная почта, к которой привязан GitHub" 

или, если в ответ приходит сообщение об ошибке (значит, система не поддерживает алгоритм шифрования ed25519), можно использовать команду с другим алгоритмом:

ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан GitHub" 

Дальше нужно указать путь для хранения ключей (т.е. где будет создана директория .ssh); если нажать enter - в корневой папке.

Дальше нужно указать пароль для доступа к ключу, но необязаетльно - можно также нажать enter (пароль останется пустым).
```

3. Если все получилось, при повторного запуске команды ls -la .ssh/ появятся 2 файла: частный ключ и публичный (.pub). Публичный ключ нужен для зашифровки, им можно делиться; приватный - для расшифровки.

4. Далее копируем содержимое публичного ключа (можно вручную, а можно через консоль командой для винды clip < clip < ~/.ssh/id_ed25519.pub или аналогичной для макос pbcopy...). Далее в гитхаб в настройках репозитория добавляем новый ключ

5. Далее проверяем в консоли, что ключ добавлен правильно: команда ssh -T git@github.com (если до этого в гитхабе ключи не добавляли, гит выдаст предупреждение, нужно ответить yes).

---

```bash
git push УР ветка
- запушить ЛР в конкретную ветку в УР

git push УР тег
- запушить теги (т.к. гит не пушит их автоматически), либо можно сразу все теги: git push УР --tags
 
git push УР --all 
- запушить в УР все локальные ветки

git push --set-upstream УР ветка (или "git push -u УР ветка")
- установить этот УР как отслеживаемый и запушить в него изменения с текущей ветки (т.е. после этого можно забирать и отправлять изменения без выбора УР и ветки, т.е.: просто писать "git pull" и "git push"). 

git push УР --delete тег 
- удалить тег из УР (т.к. гит не удаляет их автоматически) 

git push УР --delete ветка
- удалить ветку из УР
```

При запушивании может выпасть ошибка "git push rejected" и пуш отменится (например, если от нашего коммита до пуша кто-то запушил изменения в тех же файлах раньше - т.к. гит по умолчанию проверяет, чтобы наш коммит при пуше был основан на предыдущих коммитах). Ошибку можно обойти двумя способами:

```bash
git push --force 
- отключит проверку коммитов и перезапишет коммиты в УР, если будут конфликты

git push —force-with-lease
- не перезапишет коммиты, если будут конфликты, а вызовет "git push rejected" у других людей
```

---

```bash
git pull
- суть команды pull: скачивает (по умолчанию все) изменения с УР и затем сливает их с тем что есть в ЛР, делая коммит (т.е. pull = fetch УР + merge УР/ветка)


git pull --no-edit 
- автоматически сгенерировать сообщение коммита пулла

git pull УР ветка
- слить текущую ветку ЛР с указанной веткой УР

git pull --no-commit
- не создавать новый коммит, а только скачать изменения

git pull --rebase
- скачать с УР только новые коммиты и добавить их в ЛР (пример: если работаем с нескольких устройств, т.е. есть несколько ЛР - так их можно синхронизировать, не делая лишние merge-коммиты (как если бы использовали просто git pull)

git pull --no-tags 
- не загружать метки (по умолчанию, если у каких-то загружаемых из УР объектов есть метки, они тоже загрузятся) 

git pull --verbose
- с выводом подробной информации о скачанном и о слитом
```

---

```bash
git rebase ветка
- "перебазирование" текущей ветки на указанную, т.е. альтернатива git merge.

Процесс перебазирования: гит находит базовый коммит (общий родитель двух веток) и, двигаясь от него по истории текущей ветки, переносит ее коммиты на последний коммит указанной ветки (как если бы они изначально начинались от него, без ветвления). 

Если в процессе будут конфликты, то перебазирование останавливается. Далее нужно отменить его (git rebase --abort), разрешить конфликты вручную (см. ниже, тему конфликтов слияния), продолжить (git rebase --continue или git rebase --skip, в зависимости от того, какие коммиты оставить, а какие пропустить)
```

---

КОНФЛИКТЫ В GIT:

Если разные изменения сделаны на разных ветках в один и тот же файл, несколькими коммитами параллельно, а потом слиты в одну ветку - так как эти коммиты на разных ветках имеют общего прародителя, то git считает что эти изменения равноценны (и попросит вручную решить, какой вариант изменений оставить в каждом конфликтующем файле, а затем продолжить операцию (pull, merge, rebase,...), на которой остановились из-за конфликта). 

Либо можно прекратить операцию, которая вызвала конфликт, через опцию --abort:

```bash
git merge --abort 
- например, прекращаем слияние, т.е. откатывает на состояние, предшествующее merge.
```

В момент выявления конфликта git автоматически добавляет в файлы с конфликтами СПЕЦИАЛЬНЫЕ МЕТКИ, разделяя ими конфликт на 2 секции: 

1. между "<<<<<<< HEAD" и "=======" будут изменения, которые были внесены в текущей ветке/версии; 

2. а между "=======" и ">>>>>>> master" - изменения, которые были в ветке master на момент слияния (может быть указан хэш коммита вместо названия ветки).

Конфликты решаются либо автоматически:

1. Выбираем между командами:

```bash
    git checkout --ours ФАЙЛ 
    - все изменения ветки master во всех конфликтных местах отклоняются

    git checkout --theirs ФАЙЛ 
    - все изменения текущей ветки во всех конфликтных местах отклоняются
```

2. и после этого делаем git add для всех файлов с исправленным конлфиктом, коммитим их и снова повторяем операцию, на которой остановились.

Либо вручную (если нам важны изменения во всех конфликтующих ветках):

1. тогда во всех конфликтующих файлах убираем оставленные гитом метки, далее оставляем нужную нам версию изменений 

2. затем для них git add, commit и повторяем операцию, на которой остановились.

---
